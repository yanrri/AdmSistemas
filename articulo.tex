\documentclass[12pt]{article}
%\usepackage[english]{babel}
\RequirePackage[spanish]{babel}
\usepackage[spanish]{babel}
\usepackage{graphicx}
\usepackage[pdftex,bookmarks,colorlinks,breaklinks]{hyperref}  % PDF hyperlinks, with coloured links
%\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{courier}
\usepackage{epstopdf}
\usepackage{fullpage}
\usepackage{url}
\usepackage{colortbl}
\usepackage{lscape}
\usepackage{xcolor}
\usepackage[skins,listings,breakable]{tcolorbox}
%\usepackage{listings}
\lstset{
  literate = {-}{-}1,
  basicstyle=\ttfamily\footnotesize,
  breaklines=true
}

\parskip 3ex % espacio entre parrafos.


\begin{document}
%%%%%%%%%%%%%%% PORTADA %%%%%%%%%%%%%%%%%%
\pagestyle{empty}
\begin{figure}
   \centering
   \includegraphics[scale=.5]{imgs/logo.png}
\end{figure}

\begin{center}
Facultad de Ingeniería

Escuela de Ingeniería en Bioinformática

\bigskip\bigskip\bigskip\bigskip

\rule{14cm}{0.5mm}

\begin{Huge}\textbf{Informe Proyecto}\end{Huge}

\begin{Huge}\textbf{Administración de Sistemas}\end{Huge}

\rule{14cm}{0.5mm}

\bigskip\bigskip\bigskip\bigskip
\bigskip\bigskip\bigskip\bigskip
\bigskip\bigskip\bigskip\bigskip
\bigskip\bigskip\bigskip\bigskip


\begin{tabular*}{14cm}{l@{\extracolsep{\fill}}r}
\emph{Alumno:} & \emph{Profesor:}\\
Nicolás Rojas Poblete & Alejandro Valdés\\
\emph{Matrícula:} & \emph{Módulo:}\\
2016430002 & Administración de Sistemas\\
\emph{E-mail:} & \emph{Minor:}\\
nicrojas16@alumnos.utalca.cl & Desarrollo de Software y\\
& Administración de Sistemas\\
\end{tabular*}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\pagestyle{plain}
\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\listoffigures 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage%
%\listoftables%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Introducción}


\newpage
\section{Compilando programas, librerías, kernel}

\subsection{Compilando el compilador GCC}

El compilador es muy importante dentro de los sistemas informáticos, se encargan de traducir el código fuente de los programas a un lenguaje que pueda ejecutar la máquina. En sistemas Linux por lo general viene incluído el compilador GCC en una versión defecto. Para ver la versión por defecto se puede ejecutar el siguiente comando.

\begin{lstlisting}[frame=single,framexrightmargin=15pt]
$ gcc --version
gcc (Debian 8.3.0-6) 8.3.0
Copyright (C) 2018 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
\end{lstlisting}

En caso de que no se encuentre instalado, se puede instalar desde los repositorios de su distribución por apt u otro gestor de paquetes.

\begin{lstlisting}[frame=single,framexrightmargin=15pt]
$ sudo apt install gcc
\end{lstlisting}

\subsubsection{Prerequisitos GCC 9.3}

En este caso se procederá a instalar la versión 9.3 de GCC a partir de la versión 8.3 que viene en nuestro sistema instalada.

Según el sitio web de manualinux.eu\cite{mlinux} los requisitos para compilar gcc 9.3 son los siguientes:

\begin{lstlisting}[frame=single,framexrightmargin=15pt]
Gawk - (5.0.1)
M4 - (1.4.18)
Libtool - (2.4.6)
Make - (4.3)
Bison - (3.5.3)
Flex - (2.6.4)
Automake - (1.16.1)
Autoconf - (2.69)
Gettext - (0.20.1)
Gperf - (3.1)
Texinfo - (6.7)
\end{lstlisting}
\bigskip
\bigskip
\begin{lstlisting}[frame=single,framexrightmargin=15pt]
Librerias en Desarrollo

Gmp - (6.2.0)
Mpfr - (4.0.2)
Mpc - (1.1.0)
ISL - (0.18)
\end{lstlisting}

\subsubsection{Descarga y Configuración GCC 9.3}

Una vez revisadas las dependencias se procede a descargar el código fuente de GCC 9.3, esto en el ftp oficial.

\begin{lstlisting}[frame=single,framexrightmargin=15pt]
$ wget ftp://ftp.mirrorservice.org/sites/sourceware.org/pub/gcc/releases/gcc-9.3.0/gcc-9.3.0.tar.gz
\end{lstlisting}

Para descomprimir
\begin{lstlisting}[frame=single,framexrightmargin=15pt]
$ tar -xzvf gcc-9.3.0.tar.gz
\end{lstlisting}

Luego es necesario entrar en la carpeta y dentro de los archivos viene incluido un script que descarga las principales dependencias(Gmp,Mpfr,Mpc,ISL).

\begin{lstlisting}[frame=single]
$ cd gcc-9.3.0/
$ contrib/download_prerequisites
\end{lstlisting}

Luego se puede crear una carpeta aparte en dónde se configure y construya el nuevo compilador.

\begin{lstlisting}[frame=single]
$ cd ~
$ mkdir build-gcc9.3
$ cd build-gcc9.3/
\end{lstlisting}

Ahora se procede a ejecutar el ./configure con los siguiente parámetros.
\begin{lstlisting}[frame=single]
$ ../gcc-9.3.0/configure --build=x86_64-linux-gnu --host=x86_64-linux-gnu \
--target=x86_64-linux-gnu --enable-shared --enable-threads=posix \
--enable-__cxa_atexit --enable-clocale=gnu --enable-languages=c,c++,fortran \
--prefix=/usr/local/gcc-9.3 --disable-multilib --program-suffix=-9.3
\end{lstlisting}


\subsubsection{Instalación GCC 9.3}

Una vez terminada la configuración y creado el archivo make file se procede a compilar

\begin{lstlisting}[frame=single]
$ make -j 16
\end{lstlisting}
En este caso -j 16 indica la cantidad de CPUs disponibles en el sistema para la compilación. Dependiendo de la potencia puede tardar unos pocos minutos hasta un par de horas.

En este caso un CPU con 8 núcleos/16 hilos a 5.0 GHz la compilación solo tardó 15 minutos aproximadamente. 

\begin{lstlisting}[frame=single]
real    15m41.040s
user    140m26.060s
sys     3m52.618s
\end{lstlisting}

Luego como superusuario se copian los binarios al prefix indicado anteriormente en la configuración
\begin{lstlisting}[frame=single]
$ sudo make install-strip
\end{lstlisting}

Por último es necesario exportar el directorio a la variable de entorno PATH
\begin{lstlisting}[frame=single]
$ export PATH=$PATH:/usr/local/gcc-9.3/bin/
$ export export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/gcc-9.3/lib64/
\end{lstlisting}

Ahora se puede comprobar la version instalada
\begin{lstlisting}[frame=single]
$ gcc-9.3 --version
gcc-9.3 (GCC) 9.3.0
Copyright (C) 2019 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
\end{lstlisting}

\subsection{Compilando Librería KD-tree}

El primer paso es descargar el código fuente desde el repositorio oficial.
\begin{lstlisting}[frame=single]
$ wget http://nuclear.mutantstargoat.com/sw/kdtree/files/kdtree-0.5.7.tar.gz
$ tar -xzvf kdtree-0.5.7
$ cd kdtree-0.5.7/
\end{lstlisting}

Una vez listo se procede a configurar la librería y hacer la compilación.
\begin{lstlisting}[frame=single]
$ ./configure
$ make
\end{lstlisting}

\subsubsection{Creando Programa con la libraría KD-tree}

Se usa como base el ejemplo test2 incluido en el código fuente y se modifica para que solicite un punto inicial y el radio de búsqueda en el árbol. Quedando un programa como el siguiente.

\begin{tcblisting}{breakable,listing only,
  listing options={language=c,aboveskip=0pt,belowskip=0pt},
  size=fbox,boxrule=0pt,frame hidden,arc=0pt,colback=lightgray}
#include <assert.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <time.h>
#include "kdtree.h"

#define DEF_NUM_PTS 10

/* entrega la distancia euclidiana entre 2 puntos */
static double dist_sq( double *a1, double *a2, int dims );

/* numero random entre -10 y 10 */
static double rd( void );

int main(int argc, char **argv) {
  printf("Kd-tree de 3 dimensiones\n");
  int i, num_pts = DEF_NUM_PTS;
  void *ptree;
  char *data, *pch;
  struct kdres *presults;
  double pos[3], dist;
  double pt[3];
  printf("Ingrese un numero de 3 dimensiones: (Separado por un espacio) ");
  scanf("%lf %lf %lf", &pt[0],&pt[1],&pt[2]);
  double radius;
  printf("Ingrese el radio de busqueda: ");
  scanf("%lf", &radius);
  if(argc > 1 && isdigit(argv[1][0])) {
    num_pts = atoi(argv[1]);
  }
  if(!(data = malloc(num_pts))) {
    perror("malloc failed");
    return 1;
  }
  srand( time(0) );
  /* Se crea el arbol kd-tree con 3 dimensiones */
  ptree = kd_create( 3 );
  /* Se agregan nodos con datos random al arbol */
  for( i=0; i<num_pts; i++ ) {
    data[i] = 'a' + i;
    assert( 0 == kd_insert3( ptree, rd(), rd(), rd(), &data[i] ) );
  }
  /* busca los nodos mas cercanos al punto entregado en el radio entregado por e                                                                                                                            l usuario */
  presults = kd_nearest_range( ptree, pt, radius );
  /* imprime los resultados */
  printf( "found %d results:\n", kd_res_size(presults) );

  while( !kd_res_end( presults ) ) {
    /* se obtiene las coordenadas de cada nodo con resultados */
    pch = (char*)kd_res_item( presults, pos );

    /* calcula la distancia euclidiana entre el resultado del arbol y punto ingr                                                                                                                            esado por el usuario */
    dist = sqrt( dist_sq( pt, pos, 3 ) );

    /* Se imprimen los datos calculados */
    printf( "node at (%.3f, %.3f, %.3f) is %.3f away and has data=%c\n",
            pos[0], pos[1], pos[2], dist, *pch );
    /* Se recorre el siguiente resultado */
    kd_res_next( presults );
  }
  /* libera la memoria utilizada de las estructuras definidas anteriormente */
  free( data );
  kd_res_free( presults );
  kd_free( ptree );

  return 0;
}
static double dist_sq( double *a1, double *a2, int dims ) {
  double dist_sq = 0, diff;
  while( --dims >= 0 ) {
    diff = (a1[dims] - a2[dims]);
    dist_sq += diff*diff;
  }
  return dist_sq;
}
static double rd( void ) {
  return (double)rand()/RAND_MAX * 20.0 - 10.0;
}
\end{tcblisting}


Con el código listo se crea el archivo Makefile para hacer su compilación, en dónde se debe considerar la ruta en donde se encuentra la librería kd-tree. Quedando como se muestra en la siguiente imagen.

\begin{figure}[!h]
   \centering
   \includegraphics[scale=.72]{imgs/makefile_kdtree.png}
   \caption{Makefile importando librería KD-Tree}
   \label{fig1}
\end{figure}

\subsubsection{Compilación y Prueba del programa}

Se procede a compilar con make y ejecutar el el programa

\begin{lstlisting}[frame=single]
$ make
$ ./test2
\end{lstlisting}

Como se mencionó anteriormente el programa solicita datos al usuario y luego realiza la búsqueda en un árbol kd-tree generado con números al azar. En la siguiente imagen se muestra su ejecución.

\begin{figure}[!h]
   \centering
   \includegraphics[scale=.72]{imgs/kdtree.png}
   \caption{Ejecución del programa con KD-tree}
   \label{fig2}
\end{figure}
\newpage

\subsection{Compilando el Kernel}

\subsubsection{Descarga y Configuración}

Primero es necesario saber que versión del kernel viene instalada en nuestro sistema, para ello usamos el siguiente comando.

\begin{lstlisting}[frame=single]
$ uname -a
Linux admSist6 4.19.0-10-amd64 #1 SMP Debian 4.19.132-1 (2020-07-24) x86_64 GNU/Linux
\end{lstlisting}

Ahora se procede a descargar la última version estable del kernel

\begin{lstlisting}[frame=single]
$ wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.8.14.tar.xz
\end{lstlisting}

Se descomprime el paquete

\begin{lstlisting}[frame=single]
$ tar axvf linux-5.8.14.tar.xz
\end{lstlisting}

En caso de haber realizado otra configuración en el actual directorio, es necesario limpiar con los siguientes comandos.

\begin{lstlisting}[frame=single]
$ make distclean
$ make clean
\end{lstlisting}

Luego se debe copiar la configuración con la cuál se configuró el kernel instalado en nuestra máquina.
\begin{lstlisting}[frame=single]
$ cp /boot/config-4.19.0-10-amd64 .config
\end{lstlisting}

Ahora se carga esta configuración anterior para el nuevo kernel
\begin{lstlisting}[frame=single]
$ yes "" | make oldconfig
\end{lstlisting}

En este caso puede arrojar algunos errores de dependencias, en este caso fue necesario instalar flex y bison

\begin{lstlisting}[frame=single]
$ apt install flex
$ apt install bison
\end{lstlisting}

También se puede desplegar un menú en la consola para ver todas las opciones de configuración 
\begin{lstlisting}[frame=single]
$ make menuconfig
\end{lstlisting}

\newpage
\begin{figure}[!h]
   \centering
   \includegraphics[scale=.39]{imgs/config_kernel2.png}
   \caption{Menú de Configuración del Kernel}
   \label{fig3}
\end{figure}

Se deben seleccionar las opciones dependiendo del cada sistema y los requerimientos. Para este caso se cambio la configuración específica al tipo de CPU y se desactivó drivers de audio que no serán utilizados.

\begin{figure}[!h]
   \centering
   \includegraphics[scale=.40]{imgs/conf_kernel3.png}
   \caption{Configuración de la familia del CPU}
   \label{fig4}
\end{figure}

Una vez configurado se guarda todo y si vemos el contenido del archivo .config se encuentran todos los parámetros de configuración para instalar el nuevo kernel.

\begin{figure}[!h]
   \centering
   \includegraphics[scale=.39]{imgs/conf_kernel.png}
   \caption{Archivo de Configuración del Kernel}
   \label{fig5}
\end{figure}

Dentro de este archivo es importante modificar la línea que hacer referencia al certificado del kernel anterior.
\begin{lstlisting}[frame=single]
$ nano .config
CONFIG_SYSTEM_TRUSTED_KEYS=""
\end{lstlisting}

Además se puede deshabilitar la línea que crea una imagen dbg con la información del debug del kernel, esto permite que la imagen sea mucho más pequeña y así no quedarse sin espacio durante la compilación.


\begin{lstlisting}[frame=single]
$ nano .config
CONFIG_DEBUG_INFO=n
\end{lstlisting}

\subsubsection{Screen y Compilación}
Ahora quedaría compilar el kernel, para lo cual se hizó una prueba en dos máquinas , una alojada en un servidor remoto y otra localmente. 

\begin{itemize}
\item La máquina remota cuenta con 2 CPUs con 2 hilos de AMD a 2.7 GHz y 2 GB RAM 
\item La máquina local cuenta con 8 CPUs  con 16 hilos de Intel a 5.0 GHz y 16 GB RAM
\end{itemize}

Para la máquina remota se configuró el uso de screen que es un software de terminales virtuales que permiten dejar el proceso de compilación corriendo sin necesidad de estar conectado todo el tiempo al servidor remoto.

Instalación de screen
\begin{lstlisting}[frame=single]
$ apt install screen
\end{lstlisting}

Se crea una terminal en screen con nombre
\begin{lstlisting}[frame=single]
$ screen -S kernel
\end{lstlisting}

Esto nos deja lista la terminal para lanzar un proceso de larga duración en nuestro servidor remoto. Para salir se esta terminal se debe apretar CTR + A + D. Para volver a la terminal creada se pueden listar las terminales de screen creadas
\begin{lstlisting}[frame=single]
$ screen -ls
There is a screen on:
        30906.kernel    (10/10/2020 07:47:05 PM)        (Detached)
1 Socket in /run/screen/S-root.
\end{lstlisting}

Con esto podemos volver a conectarnos a esa terminal
\begin{lstlisting}[frame=single]
$ screen -r 30906.kernel
\end{lstlisting}

Finalmente dejamos corriendo la compilación del kernel
 
\begin{lstlisting}[frame=single]
$ make -j2 deb-pkg
\end{lstlisting}


Para la máquina local se usó 
\begin{lstlisting}[frame=single]
$ make -j16 deb-pkg
\end{lstlisting}

Los tiempos de ejecución en la máquina remota fueron los siguientes
\begin{lstlisting}[frame=single]
real    96m49.182s
user    168m48.511s
sys     20m3.484s
\end{lstlisting}

Mientras que en la máquina local
\begin{lstlisting}[frame=single]
real    11m7.837s
user    129m13.261s
sys     16m43.976s
\end{lstlisting}

\subsubsection{Instalación de la imagen}

Una vez terminado el proceso de compilación solo quedaría instalar la imagen .deb generada
\begin{lstlisting}[frame=single]
$ cd ..
$ dpkg -i dpkg -i linux-image-5.8.14_5.8.14-1_amd64.deb
\end{lstlisting}

Terminada la instalación se reinicia la máquina para que arranque con el nuevo kernel. 
\begin{lstlisting}[frame=single]
$ shutdown -r now
\end{lstlisting}
Si la máquina vuelve arrancar se puede verificar el kernel instalado
\begin{lstlisting}[frame=single]
$ uname -a
Linux admSist6 5.8.14 #1 SMP Sun Oct 11 04:00:29 -03 2020 x86_64 GNU/Linux
\end{lstlisting}
\newpage

\begin{thebibliography}{99}
\bibitem{mlinux} Manual Linux \url{https://manualinux.eu/gcc.html}

\end{thebibliography}
\end{document}